name: Bump Version and Create Release

# คำอธิบายการ bump version (ภาษาไทย)
#
# กฎการ bump:
# - Merge เข้า `main`:
#   - ถ้า source branch ขึ้นต้นด้วย `fix/` หรือ `hotfix/` -> bump patch: vMAJOR.MINOR.(PATCH+1)
#   - มิฉะนั้น -> bump minor: vMAJOR.(MINOR+1).0
# - Merge เข้า `development`:
#   - สร้าง/เพิ่ม pre-release บนฐานเวอร์ชันปัจจุบัน: vMAJOR.MINOR.PATCH-dev.N
#   - ถ้า source branch ขึ้นต้นด้วย `fix/` จะเพิ่ม suffix patch: vMAJOR.MINOR.PATCH-dev.N-patch.M
#
# วิธีตรวจหาเวอร์ชันปัจจุบัน:
# - จะตรวจ `git tags` ก่อน (รวม pre-release tags เช่น v0.2.0-dev.2)
# - ถ้าไม่มี tags จะ fallback ไปใช้ GitHub Releases API
# - ก่อนสร้าง tag ใหม่ workflow จะตรวจให้แน่ใจว่า tag นั้นยังว่างอยู่ (increment counters จนไม่ซ้ำ)
#
# หมายเหตุ:
# - เพื่อให้ workflow ทำงานถูกต้อง ควรมี tags ถูก push ขึ้น remote (หรือ workflow ต้องมีสิทธิ์ fetch tags)
# - หากต้องการทดสอบ locally ให้ clone repo และ `git fetch --tags` เพื่อให้มีข้อมูล tags ครบ

on:
  pull_request:
    types: closed
    branches:
      - main
      - development

jobs:
  bump-version:
    name: Bump Version and Create Release
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Get Current Version from GitHub Releases
        id: current_version
        run: |
          # Ensure we have tags locally (fetch/prune from origin)
          git fetch --prune --tags origin

          # Prefer latest tag (including pre-releases) matching semver prefix vMAJOR.MINOR.PATCH
          LATEST_TAG=$(git tag -l 'v*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+' | sort -V | tail -n1 || true)

          # if tag latest found
          if [ -n "$LATEST_TAG" ]; then
            CURRENT_VERSION="${LATEST_TAG#v}"
            echo "Found latest tag: $LATEST_TAG"
          # if tag latest not found
          else
            # Fallback to GitHub Releases API if no tags are present
            LATEST_TAG=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              https://api.github.com/repos/${{ github.repository }}/releases/latest \
              | jq -r '.tag_name // empty')
            
            # if no releases found
            if [ -z "$LATEST_TAG" ]; then
              CURRENT_VERSION="0.1.0"
              echo "No tags/releases found, using initial version"
            else
              CURRENT_VERSION="${LATEST_TAG#v}"
              echo "Found latest release: $LATEST_TAG"
            fi
          fi

          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Calculate New Version
        id: new_version
        run: |
          CURRENT=${{ steps.current_version.outputs.version }} 
          TARGET_BRANCH=${{ github.event.pull_request.base.ref }}
          SOURCE_BRANCH=${{ github.event.pull_request.head.ref }}

          echo "Target branch: $TARGET_BRANCH"
          echo "Source branch: $SOURCE_BRANCH"

          # Split version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"
          # ex. 0.1.0-dev* or 0.1.0

          # case hotfix merge to main ex. 0.1.0 -> 0.1.1
          if [ "$TARGET_BRANCH" == "main" ]; then
            echo "On main branch"
            # split out of text after PATCH -dev* out
            PATCH=${PATCH%%-*}
            # ex. 0-dev* -> 0
            # If source is not a development/, bump patch; otherwise bump minor
            if [[ "$SOURCE_BRANCH" != "development" ]]; then
              echo "SOURCE_BRANCH is not development"
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$MINOR
              NEW_PATCH=$((PATCH + 1))
              NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
              echo "Bumping main: patch bump due to hotfix branch"
            # if source is development/, bump minor ex. 0.1.0 -> 0.2.0
            else
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$((MINOR + 1))
              NEW_PATCH=0
              NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
              echo "Bumping main: minor bump"
            fi

          elif [ "$TARGET_BRANCH" == "development" ]; then
            echo "On development branch"
            if [[ "$SOURCE_BRANCH" == feat/* ]]; then
              echo "Bumping development: feature branch"
              # ถ้า PATCH มี -dev.N อยู่แล้ว ให้เพิ่ม N
              if [[ "$PATCH" == *"-dev."* ]]; then
                echo "Feature branch on development with existing dev suffix"
                DEV_PART=${PATCH#*-dev.}
                DEV_NUM=${DEV_PART%%-*}
                DEV_NUM=$((DEV_NUM + 1))
                # เก็บ prefix ก่อน -dev.N
                PREFIX=${PATCH%%-dev.*}
                PATCH="$PREFIX-dev.$DEV_NUM"
              else
                echo "Feature branch on development without existing dev suffix"
                # ถ้าไม่มี -dev.N ให้เริ่มที่ 1
                PATCH="${PATCH}-dev.1"
              fi

              NEW_MAJOR=$MAJOR
              NEW_MINOR=$MINOR
              NEW_PATCH=$PATCH
              NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
              echo "Base version for development branch: $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
            fi
          else
            echo "Unknown branch: $TARGET_BRANCH"
            exit 1
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Commit Changes
        run: |
          git add CHANGELOG.md
          git commit -m "chore: release version ${{ steps.new_version.outputs.version }}"

      - name: Create or Update Git Tag
        run: |
          TAG_NAME="v${{ steps.new_version.outputs.version }}"
          
          # Check if tag exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "Tag $TAG_NAME already exists, deleting and recreating..."
            git tag -d "$TAG_NAME"
            git push origin :"$TAG_NAME" || true
          fi
          
          # Create new tag
          git tag -a "$TAG_NAME" -m "Release version ${{ steps.new_version.outputs.version }}"
          echo "✅ Created tag: $TAG_NAME"

      - name: Push Changes and Tags
        run: |
          git push origin ${{ github.event.pull_request.base.ref }}
          git push origin v${{ steps.new_version.outputs.version }} --force

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.new_version.outputs.version }}
          release_name: Release ${{ steps.new_version.outputs.version }}
          body: |
            # Release ${{ steps.new_version.outputs.version }}

            ## Version Bump
            - Previous Version: ${{ steps.current_version.outputs.version }}
            - New Version: ${{ steps.new_version.outputs.version }}
            - Target Branch: ${{ github.event.pull_request.base.ref }}

            ## Release Details
            - PR: #${{ github.event.pull_request.number }}
            - Title: ${{ github.event.pull_request.title }}
            - Merged by: @${{ github.event.pull_request.merged_by.login }}
            - Build: [View Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

            ## Changelog
            ${{ steps.changelog.outputs.changelog }}
          draft: false